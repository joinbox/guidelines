# GET /Joinbox-RESTful-Style-Guide

This styleguide describes how RESTful Services should be designed. The target is to make the services available to other services and apps as simple as possible. Because of this it is very important all services use the same headers, parameters, encodings, methods and wokrflows.

Much of the functionality will be handled by the ee framework.


## Naming 

- **Collection**: A collection is a collection of resources like users, events or venues
- **Resource**: A resource is a single item of a collection, like one event or one user
- **Request**: Method: A HTTP request method: GET, POST, DELETE, OPTIONS, HEAD, PUT, PATCH
- **Headers**: Stadard HTTP request / response headers 
- **Body**: HTTP request / response body
- **Status**: HTTP response status code like 200, 400 or 500



## URLs

Every entity is a collection and can be accessed through an URL. The URL consits of a descriptive name of the entity. You should always use the singular form for a collection name.

**Bad**
- /Users
- /EventboosterUsers

**Good**
- /user


Resources must be made available throught an URL consisting of the collection, a slash and a unique resource identifier.

**Bad**
- /Users/byId/1
- /User1

**Good**
- /user/1
- /user/michael%40joinbox.com


A resource may have as many subresources / subcollections as required, the URL for the subresource must follow the same rules as the collection / resource it depends on. Since subresources are basically mappings they can be made avialable as subresource or a separate resource or as both.

**Bad**
- /user/1/comment
- /user/1/usercomments/3

**Good**
- /user/1/comment
- /user/1/comment/34





## Headers

### Request Haders

The following list of headers should automatically be generated by the application framework you are using on both side of the connection:
- **Content-Length**: actual payload length
- **Connection**: kep alive / close
- **Accept-Encoding**: compression


#### Accept

The content type that can be accepted, will be «Application/JSON» most of the time.
If the server cannot satisfy the request he will respond with the **406 - Not Acceptable** status.

```HTTP
GET /user HTTP/1.1
Accept: Application/JSON
```


#### Accept-Language

The requested content language. Most of the time this will be one of en, de, fr, it.
If the server cannot satisfy the request he will respond with the **406 - Not Acceptable** status.


```HTTP
GET /user HTTP/1.1
Accept-Language: de, fr;q=0.9, en;q=0.8
```

Since all language specific data is stored in mapping tables between the entit and the language entity it is **not** required to submit the accept language header. You can instead use the «Select» and «Filter» header for selecting the language data. If you use the «Accept-Language» header the service will return the resource in that specific language with the locale data flat included into the entity. If you use the «Select» header without the «Filter» header the service will return all locale records. Without the «Accept-Language» header the locale data will be returned like a mpping inside an array. See the [Locale Data]() Section.


#### Range

0 based range index, supported by most collections. Only available if the options request did return the «Accept-Ranges: resources» header
If the server cannot satisfy the request he will respond with the **416 - Requested Range Not Satisfiable** status.

```HTTP
GET /user HTTP/1.1
Range: 0-10
```


#### Content-Type

The content type of the payload on requests with body ( POST, PATCH, PUT ). Will most of the time be «Multipart/Form-Data»

```HTTP
GET /user HTTP/1.1
Content-Type: Multipart/Form-Data
```


#### Select

Custom headers for selecting data from resources / sub resources. The headers content must be delivered as comma separated list. Fields of sub entities may be selected using the «.» ( dot ). 
If the server cannot satisfy the request he will respond with the **460 - Select Not Satisfiable** status.


```HTTP
GET /user HTTP/1.1
Select: id, name, tenant.id, tenant.name, friend.name, friend.id
```


#### Filter

Custom header used for filtering collections. The filters consist of a comma separated list of keys and values. String values in the value part of the key-value pairs must be url encoded. This must not include the function name or operator. Strings must be enclosed in quotation marks.
If the server cannot satisfy the request he will respond with the **461 - Filter Not Satisfiable** status.

```HTTP
GET /user HTTP/1.1
Filter: id=in(3,4), firstName=like('mich%25')
```


#### Order

Custom header for defining the order in which the results must be returned. The complete collection is ordered before a range from it is returned in the requested order.
If the server cannot satisfy the request he will respond with the **462 - Ordering Not Satisfiable** status.

```HTTP
GET /user HTTP/1.1
Order: name, firends.name DESC
```


#### API-Version

The API version to use to respond to requests
If the server cannot satisfy the request he will respond with the **463 - Unsupported API Version** status.

```HTTP
GET /user HTTP/1.1
API-Version: 0.0.1
```



### Response Headers

#### Content-Type

The Content Type of the response


```HTTP
GET /user HTTP/1.1
Content-Type: Multipart/Form-Data
```

## Methods

### Methods available on collections

- OPTIONS
- GET
- HEAD
- DELETE
- POST


#### GET

The GET method is used to get an optional filtered, paged set of resources. 

Available request headers
- Accept
- Accept-Language
- Range
- API-Version
- Select
- Order
- Filter

The example request below will do the following:
- return the users property «id», the related tenants properties «id» and «name» and the related friends properties «id» and «name»
- filter the user by id ( in 3, 4 ) and name ( like micha% ), see [filters]()
- limit the result count to 11, starting at offset 0
- return the data in german

*Request Headers*
```HTTP
GET /user HTTP/1.1
Host: somehost:12001
Accept: Application/JSON
Accept-Language: de, fr;q=0.9, en;q=0.8
Range: 0-10
Select: id, tenant.id, tenant.name, friends.id, friends.name
Order: name DESC, firends.name DESC
Filter: id=in(3,4), firstName=like('mich%25')
API-Version: 0.0.1
```

*Response Headers*
```HTTP
HTTP/1.1 200 OK
Content-Type: Application/JSON
Date: Fri, 15 Nov 2013 12:12:14 GMT
Range: 0-10
```

*Response Body*
```Javascript
[
	{
		  id: 4
		, name: "michael"
		, tenant: {
			  id: 1
			, name: "default tenant"
			, _rel: {
				  _self: 		"/tenant/1"
				, _collection: 	"/tenant"
				, _rel: 		"/user/4/tenant/1"
			}
		}
		, friend: [
			{
				  id: 5 
				, name: "pereg"
				, _rel: {
					  _self: 		"/user/5"
					, _collection: 	"/user"
					, _rel: 		"/user/4/friend/5"
				}
			}
			, {
				  id: 4
				, name: "fabian"
				, _rel: {
					  _self: 		"/user/4"
					, _collection: 	"/user"
					, _rel: 		"/user/4/friend/4"
				}
			}
		]
		, _rel: {
			  _self: 		"/user/4"
			, _collection: 	"/user"
			, friend: 		"/user/4/friend"
			, tenant: 		"/user/4/tenant"
		}
	}
	, {
		  id: 3
		, name: "micha"
		, tenant: {
			  id: 4
			, name: "events.ch"
		}
		, friends: []
		, _rel: {
			  _self: 		"/user/3"
			, _collection: 	"/user"
			, friend: 		"/user/3/friend"
			, tenant: 		"/user/3/tenant"
		}
	}
]
```


### POST

Adds a new item to the collection automatically creating an id for the new resource. The created resource will be returned.

Available request headers
- Accept
- API-Version


*Request Headers*
```HTTP
GET /user HTTP/1.1
Host: somehost:12001
Accept: Application/JSON
Accept-Language: de, fr;q=0.9, en;q=0.8
Range: 0-10
Select: id, tenant.id, tenant.name, friends.id, friends.name
Order: name DESC, firends.name DESC
Filter: id=in(3,4), firstName=like('mich%25')
API-Version: 0.0.1
```

*Response Headers*
```HTTP
HTTP/1.1 200 OK
Content-Type: Application/JSON
Date: Fri, 15 Nov 2013 12:12:14 GMT
Range: 0-10
```

*Response Body*
```Javascript
[
	{
		  id: 4
		, name: "michael"
		, tenant: {
			  id: 1
			, name: "default tenant"
		}
		, friends: [
			{
				  id: 5 
				, name: "pereg"
			}
			, {
				  id: 4
				, name: "fabian"
			}
		]
	}
	, {
		  id: 3
		, name: "micha"
		, tenant: {
			  id: 4
			, name: "events.ch"
		}
		, friends: []
	}
]











### The OPTIONS Method

The options request returns a reponse with the allow header which contains a comma separated list of the methods supported on the collection. The response body may contain a detailed description of the collection.


*Request Headers*
```HTTP
OPTIONS /user HTTP/1.1
Host: somehost:12001
Accept: Application/JSON
```

*Response Headers*
```HTTP
HTTP/1.1 200 OK
Content-Type: Application/JSON
Date: Fri, 15 Nov 2013 12:12:14 GMT
Allow: OPTIONS,GET,POST
Accept-Ranges: resources
Accept-Select: *, tenant.*, friends.*
Accept-Order: *
Accept-Filter: id, tenant.id
```

*Response Body*

The data in the response body describes the collection / resource and the subresources of the collection / resource
```Javascript
{
	  allow: ['OPTIONS','GET','POST']
	, properties: {
		id: { 
		  	  primary: 	true
		  	, type: 	'int'
		  	, filters: 	'numbers'
		}
		, tenant: {
			id: { 
			  	  primary: 	true
			  	, type: 	'int'
			  	, filters: 	'numbers'
			}
			, name: {
				  unique: 	true
			  	, type: 	'string'
			  	, filters: 	'strings'
			}
		}
	}
	, filters: {
		  numbers: ['<', '>', '=', '!=', '>=', '<=', 'notNull', 'null', 'in']
		, strings: ['=', '!=', 'like', 'notNull', 'null', 'in']
	}
}
```


## Filters

The list below reflects all possible filters. This does not mean that all collections do have support for them. The OPTIONS resuqest on the collection should return the collections capabilities.

### Numbers

- **=**: euqals, property=4
- **!=**: not equals, property!=4
- **<**: smallet than, property< 






### Methods available on resources
- OPTIONS
- GET
- HEAD
- DELETE
- PUT
- PATCH


